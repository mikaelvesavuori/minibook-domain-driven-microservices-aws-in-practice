---
description: Design is the heart of software, regardless of your stance on coding or not.
---

# On design

As for me, who has did not graduate in Computer Science but has in some way worked with computers since I was a kid but, development is something that was learned on my own. While many years ago I might have understood what an architect did, I personally gradually learned more and more on that side as I started building my own software, distributing open source, and leading technical teams.

One side of the word "design" that I feel to be misunderstood is around how it relates to practices such as Agile and its various forms (which is something every company and context I've been at has talked about, but not really delivered on) as well as to how the architect role fit in within modern software development, the DevOps paradigm, and being generally allergic to upfront planning.

It's nice then to see that this is less a real issue than a perceived one. We can see this in how Agile framework co-founder Robert C. Martin tries to set the record straight in his [Clean Agile: Back to Basics](https://www.oreilly.com/library/view/clean-agile-back/9780135782002/) as well as in the humble "[connect the penthouse with the engine room](https://architectelevator.com)" metaphor stated by Gregor Hohpe. They both express that design is something that _must_ be done, Agile or not, and that modern circumstances do not have to pass on a golden key to some Ivory Tower dude to handle the design on their own.

## You have to design more to be better at it

Nothing has improved my own skills as much as setting up small projects with clear goals. Part of those goals should always be "What do I want to improve on, or learn?".

After having read this minibook, and maybe even trying to build the application on your own, take some time to reflect on what didn't make sense, what was hard, what you feel you can do better. Can the language improve? Can the abstractions be better handled? Can you be more expressive with relations between systems?

Reading is not the end goalâ€”designing and reflecting on the results of the process is. And domain-driven design is a solid foundation to build our design flow around, as well as informing how we practically develop our software.
